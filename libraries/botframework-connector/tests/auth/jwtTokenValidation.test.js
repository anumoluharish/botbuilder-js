// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

const assert = require('assert');
const url = require('url');
const { JwtTokenExtractor } = require('../../lib/auth/jwtTokenExtractor');
const { jwt, oauth } = require('botbuilder-test-utils');

const {
    AuthenticationConstants,
    ChannelValidation,
    EmulatorValidation,
    GovernmentChannelValidation,
    GovernmentConstants,
    JwtTokenValidation,
    SimpleCredentialProvider,
    MicrosoftAppCredentials,
} = require('../..');

describe('JwtTokenValidation', () => {
    afterEach(() => {
        JwtTokenExtractor.openIdMetadataCache.clear();
    });

    jwt.mocha();
    oauth.mocha();

    describe('authenticateRequest', () => {
        const authenticateRequest = async ({
            appId = 'appId',
            appPassword = 'password',
            assertClaims = (claims) => assert(claims.isAuthenticated),
            channelService,
            makeActivity = () => ({}),
            makeAuthHeader = (tokenType, accessToken) => `${tokenType} ${accessToken}`,
            makeClaims = (_appId, defaultClaims) => defaultClaims,
            makeCredentials = (appId, appPassword, tenant) => new MicrosoftAppCredentials(appId, appPassword, tenant),
            makeProvider = (appId, appPassword) => new SimpleCredentialProvider(appId, appPassword),
            openId,
            parameters,
            rejectsWith,
            skippedJwt = false,
            tenant = 'common',
            version = '1.0',
        }) => {
            openId = url.parse(openId);
            console.log(openId);

            // Stub OpenID/JWKS calls so that we can generate signed JWTs in the tests
            const { sign, verify: verifyJwt } = jwt.stub(
                {
                    jwks: { ...openId, path: '/.well-known/v2.0/jwks' },
                    oauth: { ...openId, path: '/oauth2/v2.0/token' },
                    openId,
                },
                {
                    issuer: parameters.issuer[0],
                }
            );

            const credentials = makeCredentials(appId, appPassword, tenant);
            const activity = makeActivity();

            // Stub oauth calls with nock. The received token is the signed claims generated by the caller.
            const { verify: verifyOauth, tokenType } = oauth.stub(
                { ...openId, path: '/oauth2/v2.0/token' },
                {
                    accessToken: sign(
                        makeClaims(appId, {
                            [AuthenticationConstants.ServiceUrlClaim]: activity.serviceUrl,
                            [AuthenticationConstants.VersionClaim]: version,
                            tid: tenant,
                        })
                    ),
                }
            );

            // Fetch "stubbed" token
            const accessToken = await credentials.getToken(true);

            // Ensure all oauth expectations are met
            verifyOauth();

            const provider = makeProvider(appId, appPassword);

            // Do not await so that we support expecting resolution or rejection
            const promise = JwtTokenValidation.authenticateRequest(
                activity,
                makeAuthHeader(tokenType, accessToken),
                provider,
                channelService
            );

            // Assert expected results
            if (rejectsWith) {
                await assert.rejects(promise, rejectsWith);
            } else {
                assertClaims(await promise);
            }

            // Ensure all JWT expectations are met
            verifyJwt(skippedJwt);
        };

        const makeAppIdClaims = (appId, defaultClaims) => ({
            ...defaultClaims,
            [AuthenticationConstants.AppIdClaim]: appId,
        });

        const makeAudClaims = (appId, defaultClaims) => ({
            ...defaultClaims,
            [AuthenticationConstants.AudienceClaim]: appId,
        });

        const generateTests = (openId, makeClaims) => [
            {
                makeClaims,
                openId,
            },
            {
                label: 'fails when claimed app ID differs from credentials app ID',
                makeClaims: (_appId, defaultClaims) => makeClaims('unexpectedAppId', defaultClaims),
                openId,
                rejectsWith: {
                    message: 'Unauthorized. Invalid AppId passed on token: unexpectedAppId',
                },
            },
            {
                label: 'fails with empty auth header',
                makeAuthHeader: () => '',
                makeClaims,
                openId,
                rejectsWith: {
                    message: 'Unauthorized Access. Request is not authorized',
                },
                skippedJwt: true,
            },
            {
                assertClaims: (claims) => {
                    assert(claims.isAuthenticated);
                    assert.strictEqual(claims.getClaimValue('tid'), 'tenant.com');
                },
                only: true,
                label: 'succeeds with a specific tenant',
                makeClaims,
                openId,
                tenant: 'tenant.com',
            },
            {
                assertClaims: (claims) => {
                    assert(claims.isAuthenticated);
                    assert.strictEqual(
                        claims.getClaimValue(AuthenticationConstants.ServiceUrlClaim),
                        'https://service.url'
                    );
                },
                label: 'succeeds with a specific tenant',
                makeActivity: () => ({ serviceUrl: 'https://service.url' }),
                makeClaims,
                openId,
            },
            {
                assertClaims: (claims) => {
                    assert(claims.isAuthenticated);
                    assert.deepStrictEqual(claims.claims, []);
                },
                label: 'succeeds with anonymous auth',
                makeAuthHeader: () => '',
                makeClaims,
                makeProvider: () => new SimpleCredentialProvider(),
                openId,
                skippedJwt: true,
            },
        ];

        const testGroups = [
            {
                label: 'Emulator',
                only: true,
                parameters: EmulatorValidation.ToBotFromEmulatorTokenValidationParameters,
                tests: [
                    ...generateTests(AuthenticationConstants.ToBotFromEmulatorOpenIdMetadataUrl, makeAppIdClaims),
                    {
                        label: 'fails with missing app ID claim',
                        openId: AuthenticationConstants.ToBotFromEmulatorOpenIdMetadataUrl,
                        rejectsWith: {
                            message: 'Unauthorized. "appid" claim is required on Emulator Token version "1.0".',
                        },
                    },
                ],
            },
            {
                label: 'Public Cloud',
                parameters: ChannelValidation.ToBotFromChannelTokenValidationParameters,
                tests: [
                    ...generateTests(AuthenticationConstants.ToBotFromChannelOpenIdMetadataUrl, makeAudClaims),
                    {
                        label: 'fails with missing app ID claim',
                        openId: AuthenticationConstants.ToBotFromChannelOpenIdMetadataUrl,
                        rejectsWith: {
                            message: 'Unauthorized. Invalid AppId passed on token: null',
                        },
                    },
                ],
            },
            {
                label: 'Government Cloud',
                channelService: GovernmentConstants.ChannelService,
                parameters: GovernmentChannelValidation.ToBotFromGovernmentChannelTokenValidationParameters,
                tests: [
                    ...generateTests(GovernmentConstants.ToBotFromChannelOpenIdMetadataUrl, makeAudClaims),
                    {
                        label: 'fails with missing app ID claim',
                        openId: GovernmentConstants.ToBotFromChannelOpenIdMetadataUrl,
                        rejectsWith: {
                            message: 'Unauthorized. Invalid AppId passed on token: null',
                        },
                    },
                ],
            },
        ];

        testGroups.forEach(({ label, only, tests = [], ...groupParams }) => {
            const register = only ? describe.only : describe;
            register(label, () => {
                tests.forEach(({ label = 'succeeds', only, ...testParams }) => {
                    const register = only ? it.only : it;
                    register(label, () => authenticateRequest({ ...groupParams, ...testParams }));
                });
            });
        });
    });
});
